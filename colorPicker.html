<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Color Picker</title>
</head>
<body>
<style>
    .hex-input {
        border: 1px solid gray;
        outline: none;
    }

    .cp-invalid {
        border: 1px solid red;
    }

    .nomouse {
        pointer-events: none;
    }

    .cp-toolbar {
        margin-top: 5px;
    }

    .cp-col {
        float: left;
        width: 180px;
    }

    .color-display {
        width: 150px;
        height: 30px;
        background: red;
        float: right;
    }
</style>
<div class="color-picker">
    <svg width="364" height="320">
        <defs>
            <linearGradient id="rainbow" x1="0%" y1="0%" x2="100%" y2="0%">
            </linearGradient>
            <linearGradient id="lightness" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color: white;stop-opacity: 1"></stop>
                <stop offset="49.9%" style="stop-color: white;stop-opacity: 0"></stop>
                <stop offset="50%" style="stop-color: black;stop-opacity: 0"></stop>
                <stop offset="100%" style="stop-color: black;stop-opacity: 1"></stop>
            </linearGradient>
            <linearGradient id="saturation" x1="0%" y1="0%" x2="0%" y2="100%">
            </linearGradient>
        </defs>
        <g transform="translate(0,10)">

            <rect class="rainbow" height="300" width="300" fill="url(#rainbow)"></rect>
            <rect class="nomouse" height="300" width="300" fill="url(#lightness)"></rect>
            <rect class="saturation" height="300" width="50" x="310" fill="url(#saturation)"></rect>
            <g class="color-dot">
                <rect x="-7" y="-7" width="16" height="16" stroke="white" fill="none"></rect>
                <rect x="-8" y="-8" width="16" height="16" stroke="black" fill="none"></rect>
            </g>
            <g class="sat-slider">
                <rect width="54" height="16" stroke="white" fill="none"></rect>
                <rect x="-1" y="-1" width="54" height="16" stroke="black" fill="none"></rect>
            </g>
        </g>
    </svg>
</div>
<div class="cp-toolbar">
    <div class="cp-col">
        <span>#</span><input class="hex-input" value="54F100" spellcheck="false">
    </div>
    <div class="cp-col">
        <div class="color-display"></div>
    </div>
</div>
<script>
    let COLOR = 'FFFF88';
    const SIZE = 300;
    const HEX_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];
    const svg = document.querySelector('svg');
    const rainbow = document.querySelector('.rainbow');
    const saturation = document.querySelector('.saturation');
    const rainbowGradient = document.querySelector('#rainbow');
    const saturationGradient = document.querySelector('#saturation');
    const colorDot = document.querySelector('.color-dot');
    const saturationSlider = document.querySelector('.sat-slider');
    const colorDisplay = document.querySelector('.color-display');
    const colors = [
        { h: 0 },
        { h: 64 },
        { h: 128 },
        { h: 196 },
        { h: 255 },
        { h: 300 },
    ];

    const stepSize = Math.floor(100 / (colors.length - 1));
    const input = document.querySelector('.hex-input');
    input.addEventListener('input', handleInput);

    function handleInput () {
        input.value = Array.from(input.value.toUpperCase().slice(0, 6))
            .filter(char => HEX_CHARS.includes(char)).join('');
        if (input.value.length < 6) {
            input.classList.add('cp-invalid');
            return;
        }
        COLOR = input.value;
        input.classList.remove('cp-invalid');
        colorDot.setAttribute('transform', `translate(${getColorX(COLOR)},${getColorY(COLOR)})`);
        let color = hexToHsl(COLOR);
        rainbowGradient.innerHTML = colors.map((c, i) => {
            return `<stop offset="${i * stepSize}%" style="stop-color:hsl(${c.h},${color[1] * 100}%,${50}%);stop-opacity:1" />`
        }).join('\n');
        saturationGradient.innerHTML = `<stop offset="0%" style="stop-color:hsl(${color[0] * 360},100%,${color[2] * 100}%);stop-opacity:1" /><stop offset="100%" style="stop-color:hsl(${color[0] * 360},0%,${color[2] * 100}%);stop-opacity:1" />`;
        saturationSlider.setAttribute('transform', `translate(309, ${300 - color[1] * 300 - 8})`)
        colorDisplay.style.backgroundColor = `#${COLOR}`;
    }

    handleInput();
    rainbow.addEventListener('mousedown', e => {
        setColor(e);
        rainbow.addEventListener('mousemove', setColor);
    });

    rainbow.addEventListener('touchstart', e => {
        setColor(e);
        rainbow.addEventListener('touchmove', setColor);
    });


    saturation.addEventListener('mousedown', e => {
        setSaturation(e);
        saturation.addEventListener('mousemove', setSaturation);
    });

    saturation.addEventListener('touchstart', e => {
        setSaturation(e);
        saturation.addEventListener('touchmove', setSaturation);
    });

    document.addEventListener('mouseup', e => {
        rainbow.removeEventListener('mousemove', setColor);
        saturation.removeEventListener('mousemove', setSaturation);
    });
    document.addEventListener('touchend', e => {
        rainbow.removeEventListener('touchmove', setColor);
        saturation.removeEventListener('touchmove', setSaturation);
    });

    function setColor (e) {
        killE(e);
        if (e.touches) e = e.touches[0];
        let p = cursorPoint(e);
        let color = hexToHsl(COLOR);
        color[0] = (p.x) / 360;
        color[2] = 1 - (p.y - 10) / 300;
        COLOR = hslToHex(...color);
        input.value = COLOR;
        handleInput();
    }

    function setSaturation (e) {
        killE(e);
        if (e.touches) e = e.touches[0];
        let p = cursorPoint(e);
        let color = hexToHsl(COLOR);
        color[1] = 1 - (p.y - 10) / 300;
        COLOR = hslToHex(...color);
        input.value = COLOR;
        handleInput();
    }

    function getColorX (hex) {
        let hsl = hexToHsl(hex);
        return Math.round(hsl[0] * (SIZE + SIZE / 5));
    }

    function getColorY (hex) {
        let hsl = hexToHsl(hex);
        return 300 - Math.round(hsl[2] * SIZE);
    }

    function hexToHsl (hex) {
        return rgbToHsl(...hexToRgb(hex));
    }

    function hslToHex (h, s, l) {
        let r, g, b;
        if (s === 0) {
            r = g = b = l; // achromatic
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }
        const toHex = x => {
            const hex = Math.round(x * 255).toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        };
        return `${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    function hexToRgb (hex) {
        return [
            parseInt(hex.substr(0, 2), 16),
            parseInt(hex.substr(2, 2), 16),
            parseInt(hex.substr(4, 2), 16),
        ];
    }

    function rgbToHsl (r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;
        let max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0; // achromatic
        } else {
            let d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }

        return [h, s, l];
    }

    function cursorPoint (evt) {
        let svgPoint = svg.createSVGPoint();
        svgPoint.x = evt.clientX;
        svgPoint.y = evt.clientY;
        return svgPoint.matrixTransform(svg.getScreenCTM().inverse());
    }

    function killE (e) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
    }
</script>
</body>
</html>